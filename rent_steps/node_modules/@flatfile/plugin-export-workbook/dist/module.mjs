import $8zX1l$flatfileapi from "@flatfile/api";
import {logInfo as $8zX1l$logInfo, processRecords as $8zX1l$processRecords, logError as $8zX1l$logError} from "@flatfile/util-common";
import * as $8zX1l$fs from "fs";
import $8zX1l$path from "path";
import {pipe as $8zX1l$pipe, reduce as $8zX1l$reduce, map as $8zX1l$map, length as $8zX1l$length} from "remeda";
import {utils as $8zX1l$utils, set_fs as $8zX1l$set_fs, writeFile as $8zX1l$writeFile} from "xlsx";







const $381f5cd2b332ac93$export$77585b2203a81f17 = async (event, options)=>{
    const { environmentId: environmentId, jobId: jobId, spaceId: spaceId, workbookId: workbookId } = event.context;
    try {
        const { data: workbook } = await (0, $8zX1l$flatfileapi).workbooks.get(workbookId);
        const { data: sheets } = await (0, $8zX1l$flatfileapi).sheets.list({
            workbookId: workbookId
        });
        const fileName = $381f5cd2b332ac93$var$sanitizeFileName(workbook.name);
        if (options.debug) {
            const meta = $8zX1l$pipe(sheets, $8zX1l$reduce((acc, sheet)=>{
                return acc + `\n\t'${sheet.name}' (${sheet.id})`;
            }, ""));
            (0, $8zX1l$logInfo)("@flatfile/plugin-export-workbook", `Sheets found in Flatfile workbook: ${meta}`);
        }
        const xlsxWorkbook = $8zX1l$utils.book_new();
        try {
            await (0, $8zX1l$flatfileapi).jobs.ack(jobId, {
                info: "Starting job to write to Excel file",
                progress: 10
            });
            for (const [sheetIndex, sheet] of sheets.entries()){
                if (options.excludedSheets?.includes(sheet.config.slug)) {
                    if (options.debug) (0, $8zX1l$logInfo)("@flatfile/plugin-export-workbook", `Skipping sheet: ${sheet.name}`);
                    continue;
                }
                try {
                    let results = await (0, $8zX1l$processRecords)(sheet.id, (records)=>{
                        return $8zX1l$pipe(records, $8zX1l$map(({ id: recordId, values: row })=>{
                            const rowValue = $8zX1l$pipe(Object.keys(row), $8zX1l$reduce((acc, colName)=>{
                                if (options.excludeFields?.includes(colName)) return acc;
                                const formatCell = (cellValue)=>{
                                    const { value: value, messages: messages } = cellValue;
                                    const cell = {
                                        t: "s",
                                        v: value,
                                        c: []
                                    };
                                    if ($8zX1l$length(messages) > 0) {
                                        cell.c = messages.map((m)=>({
                                                a: "Flatfile",
                                                t: `[${m.type.toUpperCase()}]: ${m.message}`,
                                                T: true
                                            }));
                                        cell.c.hidden = true;
                                    }
                                    return cell;
                                };
                                return {
                                    ...acc,
                                    [colName]: formatCell(row[colName])
                                };
                            }, {}));
                            return options?.includeRecordIds ? {
                                recordId: recordId,
                                ...rowValue
                            } : rowValue;
                        }));
                    }, {
                        filter: options.recordFilter
                    });
                    if (!results || results.every((group)=>group.length === 0)) {
                        const emptyCell = {
                            t: "s",
                            v: "",
                            c: []
                        };
                        results = [
                            sheet.config.fields.map((field)=>({
                                    [field.key]: emptyCell
                                }))
                        ];
                    }
                    const rows = results.flat();
                    const worksheet = $8zX1l$utils.json_to_sheet(rows);
                    $8zX1l$utils.book_append_sheet(xlsxWorkbook, worksheet, $381f5cd2b332ac93$var$sanitizeExcelSheetName(sheet.name, sheetIndex));
                } catch (_getRecordsError) {
                    (0, $8zX1l$logError)("@flatfile/plugin-export-workbook", `Failed to fetch records for sheet with id: ${sheet.id}`);
                    await (0, $8zX1l$flatfileapi).jobs.fail(jobId, {
                        outcome: {
                            message: `Failed to fetch records for sheet with id: ${sheet.id}`
                        }
                    });
                    return;
                }
            }
        } catch (_jobAckError) {
            (0, $8zX1l$logError)("@flatfile/plugin-export-workbook", `Failed to acknowledge job with id: ${jobId}`);
            await (0, $8zX1l$flatfileapi).jobs.fail(jobId, {
                outcome: {
                    message: `Failed to acknowledge job with id: ${jobId}`
                }
            });
            return;
        }
        // Lambdas only allow writing to /tmp directory
        const timestamp = new Date().toISOString();
        const filePath = (0, $8zX1l$path).join("/tmp", `${fileName}-${timestamp}.xlsx`);
        if (xlsxWorkbook.SheetNames.length === 0) {
            if (options.debug) (0, $8zX1l$logError)("@flatfile/plugin-export-workbook", "No data to write to Excel file");
            await (0, $8zX1l$flatfileapi).jobs.fail(jobId, {
                outcome: {
                    message: "Job failed because there were no data to write to Excel file."
                }
            });
            return;
        }
        try {
            $8zX1l$set_fs($8zX1l$fs);
            $8zX1l$writeFile(xlsxWorkbook, filePath);
            if (options.debug) (0, $8zX1l$logInfo)("@flatfile/plugin-export-workbook", "File written to disk");
        } catch (_writeError) {
            (0, $8zX1l$logError)("@flatfile/plugin-export-workbook", "Failed to write file to disk");
            await (0, $8zX1l$flatfileapi).jobs.fail(jobId, {
                outcome: {
                    message: "Job failed because it could not write the Excel Workbook to disk."
                }
            });
            return;
        }
        try {
            const reader = $8zX1l$fs.createReadStream(filePath);
            await (0, $8zX1l$flatfileapi).files.upload(reader, {
                spaceId: spaceId,
                environmentId: environmentId,
                mode: "export"
            });
            reader.close();
            await $8zX1l$fs.promises.unlink(filePath);
            if (options.debug) (0, $8zX1l$logInfo)("@flatfile/plugin-export-workbook", `Excel document uploaded. View file at https://spaces.flatfile.com/space/${spaceId}/files?mode=export`);
        } catch (_uploadError) {
            (0, $8zX1l$logError)("@flatfile/plugin-export-workbook", "Failed to upload file");
            await (0, $8zX1l$flatfileapi).jobs.fail(jobId, {
                outcome: {
                    message: "Job failed because it could not upload Excel file."
                }
            });
            return;
        }
        try {
            await (0, $8zX1l$flatfileapi).jobs.complete(jobId, {
                outcome: {
                    acknowledge: true,
                    message: 'Data was successfully written to Excel file and uploaded. You can access the workbook in the "Available Downloads" section of the Files page in Flatfile.',
                    next: {
                        type: "id",
                        id: spaceId,
                        path: "files",
                        query: "mode=export",
                        label: "See all downloads"
                    }
                }
            });
            if (options.debug) (0, $8zX1l$logInfo)("@flatfile/plugin-export-workbook", "Done");
        } catch (_jobError) {
            (0, $8zX1l$logError)("@flatfile/plugin-export-workbook", "Failed to complete job");
            await (0, $8zX1l$flatfileapi).jobs.fail(jobId, {
                outcome: {
                    message: "Failed to complete job."
                }
            });
            return;
        }
    } catch (_fetchSheetsError) {
        (0, $8zX1l$logError)("@flatfile/plugin-export-workbook", `Failed to fetch sheets for workbook id: ${workbookId}`);
        await (0, $8zX1l$flatfileapi).jobs.fail(jobId, {
            outcome: {
                message: `Failed to fetch sheets for workbook id: ${workbookId}`
            }
        });
        return;
    }
};
function $381f5cd2b332ac93$var$sanitizeFileName(fileName) {
    // List of invalid characters that are commonly not allowed in file names
    const invalidChars = /[\/\?%\*:|"<>]/g;
    // Remove invalid characters
    let cleanFileName = fileName.replace(invalidChars, "_");
    // Remove emojis and other non-ASCII characters
    cleanFileName = cleanFileName.replace(/[^\x00-\x7F]/g, "");
    return cleanFileName;
}
function $381f5cd2b332ac93$var$sanitizeExcelSheetName(name, index) {
    // Regular expression to match unsupported Excel characters
    const invalidChars = /[\\\/\?\*\[\]:<>|"]/g;
    // Remove unsupported characters and trim leading or trailing spaces
    let sanitized = name.replace(invalidChars, "").trim();
    // Remove leading or trailing apostrophes
    sanitized = sanitized.replace(/^'+|'+$/g, "");
    // Truncate to 31 characters, the maximum length for Excel sheet names
    if (sanitized.length > 31) sanitized = sanitized.substring(0, 31);
    // If the sheet name is empty, use a default name based on index (i.e. "Sheet1")
    if (sanitized.length === 0) sanitized = `Sheet${index + 1}` //index is 0-based, default sheet names should be 1-based
    ;
    return sanitized;
}
/**
 * Generates the alpha pattern ["A", "B", ... "AA", "AB", ..., "AAA", "AAB", ...] to help
 * with accessing cells in a worksheet.
 *
 * @param length - multiple of 26
 */ const $381f5cd2b332ac93$var$genCyclicPattern = (length = 104)=>{
    let alphaPattern = [];
    for(let i = 0; i < length; i++){
        let columnName = "";
        let j = i;
        while(j >= 0){
            columnName = String.fromCharCode(65 + j % 26) + columnName // 65 is ASCII for 'A'
            ;
            j = Math.floor(j / 26) - 1;
        }
        alphaPattern.push(columnName);
    }
    return alphaPattern;
};


const $2585b17ba9bd3778$export$977d268a4eabb46 = (opts = {})=>{
    return (listener)=>{
        listener.on("job:ready", {
            job: opts.jobName || "workbook:downloadWorkbook"
        }, async (event)=>{
            await (0, $381f5cd2b332ac93$export$77585b2203a81f17)(event, opts);
        });
    };
};


export {$2585b17ba9bd3778$export$977d268a4eabb46 as exportRecordsPlugin, $2585b17ba9bd3778$export$977d268a4eabb46 as exportWorkbookPlugin};
//# sourceMappingURL=module.mjs.map
