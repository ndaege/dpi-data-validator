{"version":3,"file":"index.mjs","sources":["../../cross-env-config/dist/index.mjs","../src/events/authenticated.client.ts","../src/utils/helpers.ts","../src/events/cache.ts","../src/events/flatfile.event.ts","../src/events/glob.match.ts","../src/events/event.handler.ts","../src/flatfile.listener.ts","../src/event-drivers/_EventDriver.ts","../src/event-drivers/Browser.ts","../src/event-drivers/FlatfileVirtualMachine.ts","../src/index.ts"],"sourcesContent":["// src/index.ts\nvar CrossEnvConfig = class {\n  /**\n   * Get a config value from either the environment or any registry overrides\n   * @param prop\n   */\n  static get(prop) {\n    return this.safeEnvLookup(prop);\n  }\n  /**\n   * Set a value explicitly\n   *\n   * @param key\n   * @param value\n   */\n  static set(key, value) {\n    return this._overrides.set(key, value);\n  }\n  /**\n   * Alias a key to another key if helpful. This is useful if you have different naming\n   * constructs for different environments.\n   *\n   * @param from\n   * @param to\n   */\n  static alias(from, to) {\n    return this._aliases.set(from, to);\n  }\n  /**\n   * Helpful if you've decided to store settings in another object and want to\n   * make that available here. For example in client-side implementations you may reserve\n   * a window.FLATFILE_CONFIG object to store settings.\n   *\n   * @param obj\n   */\n  static attachConfigRegistry(obj) {\n    this._registry = obj;\n  }\n  /**\n   * Use this to provide an override getter for config values. This is useful\n   * if you need to dynamically look up values. Overrides will still take precedence.\n   *\n   * @param cb\n   */\n  static attachConfigFactory(cb) {\n    this._factory = cb;\n  }\n  static reset() {\n    this._overrides = /* @__PURE__ */ new Map();\n    this._registry = void 0;\n    this._factory = void 0;\n  }\n  /**\n   * Internal function for traversing the possible environment sources for a value\n   *\n   * @param prop\n   * @private\n   */\n  static safeEnvLookup(prop) {\n    let values = [];\n    if (this._overrides.get(prop)) {\n      values.push(this._overrides.get(prop));\n    }\n    if (typeof this._registry === \"object\") {\n      values.push(this._registry[prop]);\n    }\n    if (typeof this._factory === \"function\") {\n      values.push(this._factory(prop));\n    }\n    if (typeof process === \"object\" && typeof process.env === \"object\") {\n      values.push(process.env[prop]);\n    }\n    values.push(...this.checkForBrowserVariables(prop));\n    const foundValue = values.find((v) => v !== void 0);\n    if (foundValue !== void 0) {\n      return foundValue;\n    }\n    const alias = this._aliases.get(prop);\n    if (alias) {\n      return this.safeEnvLookup(alias);\n    }\n    return void 0;\n  }\n  /**\n   * Internal function for checking for stored variables in a browser-like environment\n   *\n   * @param prop\n   * @private\n   */\n  static checkForBrowserVariables(prop) {\n    let values = [];\n    if (typeof window === \"object\") {\n      const windowValue = window[`CROSSENV_${prop}`];\n      if (windowValue !== void 0) {\n        values.push(windowValue);\n      }\n      if (typeof sessionStorage === \"object\") {\n        const storedValue = sessionStorage.getItem(`CROSSENV_${prop}`);\n        if (storedValue !== null) {\n          values.push(storedValue);\n        }\n      }\n    }\n    return values;\n  }\n};\nCrossEnvConfig._overrides = /* @__PURE__ */ new Map();\n/**\n * A map of aliases that can be used to look up config values.\n *\n * @private\n */\nCrossEnvConfig._aliases = /* @__PURE__ */ new Map();\nexport {\n  CrossEnvConfig\n};\n","import { CrossEnvConfig } from '@flatfile/cross-env-config'\nimport fetch from 'cross-fetch'\nimport { ensureSingleTrailingSlash } from '../utils/helpers'\n\nexport class AuthenticatedClient {\n  public _accessToken?: string\n  public _apiUrl?: string\n\n  constructor(accessToken?: string, apiUrl?: string) {\n    const FLATFILE_API_URL =\n      CrossEnvConfig.get('AGENT_INTERNAL_URL') || 'http://localhost:3000'\n    const bearerToken = CrossEnvConfig.get('FLATFILE_BEARER_TOKEN')\n\n    this._accessToken = accessToken || bearerToken || '...'\n\n    this._apiUrl =\n      apiUrl || FLATFILE_API_URL\n        ? ensureSingleTrailingSlash(apiUrl || FLATFILE_API_URL)\n        : undefined\n  }\n\n  async fetch(url: string, options?: any) {\n    const headers = {\n      Authorization: `Bearer ${this._accessToken}`,\n      'x-disable-hooks': 'true',\n      'Content-Type': 'application/json',\n      ...options?.headers,\n    }\n\n    const fetchUrl = this._apiUrl + url\n\n    const fetchOptions = {\n      method: options?.method || 'GET',\n      headers,\n      body: options?.data,\n    }\n\n    try {\n      const response = await fetch(fetchUrl, fetchOptions)\n\n      if (response.status >= 200 && response.status <= 399) {\n        const contentType = response.headers.get('content-type')\n        if (contentType && contentType.includes('application/json')) {\n          const responseData = (await response.json()) as { data: any }\n          return responseData.data\n        } else {\n          const responseData = await response.text()\n          return responseData\n        }\n      } else {\n        throw new Error(`HTTP error! Status: ${response.status}`)\n      }\n    } catch (err) {\n      console.log('event.fetch error: ', err)\n    }\n  }\n\n  /**\n   *\n   * @deprecated use @flatfile/cross-env-config instead\n   */\n  public setVariables({\n    accessToken,\n    apiUrl,\n  }: {\n    accessToken?: string\n    apiUrl?: string\n  }) {\n    this._accessToken = accessToken\n    this._apiUrl = apiUrl\n  }\n}\n","export const ensureSingleTrailingSlash = (url: string) => {\n  // Remove all trailing slashes\n  while (url.endsWith('/')) {\n    url = url.slice(0, -1)\n  }\n\n  // Append one slash\n  return url + '/'\n}\n","export class EventCache {\n  private eventCache: Map<any, any> = new Map()\n\n  async init<T>(key: string, callback: () => Promise<T>): Promise<T> {\n    if (this.eventCache.get(key)) {\n      return this.eventCache.get(key)\n    } else {\n      const result = await callback()\n      this.eventCache.set(key, result)\n      return result\n    }\n  }\n\n  async set<T>(key: string, callback: () => Promise<T>): Promise<T> {\n    if (this.eventCache.get(key)) {\n      const result = await callback()\n      this.eventCache.set(key, result)\n      return result\n    } else {\n      throw new Error('Cache key not found')\n    }\n  }\n\n  get<T>(key: string): T {\n    if (this.eventCache.get(key)) {\n      return this.eventCache.get(key)\n    } else {\n      throw new Error('Cache key not found')\n    }\n  }\n\n  delete(key?: string | string[]): void {\n    if (!key) {\n      this.eventCache.clear()\n    } else if (this.eventCache.get(key)) {\n      if (Array.isArray(key)) {\n        key.forEach((k) => this.eventCache.delete(k))\n      } else {\n        this.eventCache.delete(key)\n      }\n    } else {\n      throw new Error('Cache key not found')\n    }\n  }\n}\n","import { AuthenticatedClient } from './authenticated.client'\n\nimport { Event, RecordsWithLinks } from '@flatfile/api/api'\nimport { EventCache } from './cache'\n\nimport pako from 'pako'\n\ntype GetDataOptions = { [key: string]: any }\ninterface GetData extends Function {\n  (options?: GetDataOptions): Promise<any>\n  then<TResult1 = any, TResult2 = any>(\n    onfulfilled?: ((value: any) => TResult1 | PromiseLike<TResult1>) | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null\n  ): Promise<TResult1 | TResult2>\n}\n\nexport class FlatfileEvent extends AuthenticatedClient {\n  /**\n   * Event ID from the API\n   *\n   * @example us0_ev_82hgidh9skd\n   * @readonly\n   *\n   */\n  public readonly id?: string\n\n  /**\n   * Topic the event was produced on\n   *\n   * @example workbook:created\n   * @readonly\n   */\n  public readonly topic: string\n  public readonly domain: string\n  public readonly target: string\n  public readonly origin: object\n  public readonly action: string\n  public readonly context: any\n  public readonly payload: any\n  public readonly cache: EventCache\n  public readonly namespace: string[]\n  public readonly createdAt?: Date\n  /**\n   * Fetch record data from Flatfile API via the event's dataUrl\n   *\n   * @async\n   * @param {object} options\n   * @returns {Promise<any>} JSON\n   */\n  public data: GetData\n\n  constructor(\n    public readonly src: Event,\n    accessToken?: string,\n    apiUrl?: string\n  ) {\n    super(accessToken, apiUrl)\n    this.cache = new EventCache()\n    this.domain = src.domain\n    this.topic = src.topic\n    this.context = src.context // -> [us0_acc_ihjh8943h9w, space_id, workbook_id]\n    this.payload = src.payload\n    this.target = src.target || ''\n    this.origin = src.origin || {}\n    this.action = src.context?.actionName || ''\n    this.namespace = src.namespaces || []\n    this.createdAt = src.createdAt || undefined\n\n    const data = async (options?: GetDataOptions): Promise<any> =>\n      this.fetchData(options)\n\n    data.then = <TResult1 = any, TResult2 = any>(\n      onfulfilled?: ((value: any) => TResult1 | PromiseLike<TResult1>) | null,\n      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null\n    ): Promise<TResult1 | TResult2> => {\n      return this.data().then(onfulfilled, onrejected)\n    }\n\n    this.data = data\n  }\n\n  /**\n   * Should return either event body if expanded already or fetch data from the\n   * signed dataURL\n   */\n  private async fetchData(options?: GetDataOptions): Promise<any> {\n    const dataUrl = new URLSearchParams(this.src.dataUrl)\n    if (options) {\n      for (const [key, values] of Object.entries(options)) {\n        if (Array.isArray(values)) {\n          for (const value of values) {\n            dataUrl.append(key, value)\n          }\n        } else {\n          dataUrl.append(key, values)\n        }\n      }\n    }\n    const decodedURL = decodeURIComponent(dataUrl.toString())\n    if (decodedURL) {\n      return this.fetch(decodedURL)\n    } else {\n      return this.payload\n    }\n  }\n\n  private afterAllCallbacks: Map<any, any> = new Map()\n  afterAll<T>(callback: () => T, cacheKey?: string): void {\n    const key = cacheKey || callback.toString()\n    if (!this.afterAllCallbacks.get(key)) {\n      this.afterAllCallbacks.set(key, callback)\n    }\n  }\n\n  async update(records: RecordsWithLinks, compressRequestBody = true) {\n    if (!this.src.dataUrl) {\n      throw new Error('Cannot set data on an event without a dataUrl')\n    }\n\n    // TODO: do we need to remove source from the messages array?\n    records.map((record) => {\n      record.messages?.map((message) => {\n        delete message.source\n      })\n    })\n\n    const data = compressRequestBody\n      ? pako.gzip(JSON.stringify(records))\n      : records\n\n    const headers = compressRequestBody\n      ? { 'Content-Encoding': 'gzip', 'Content-Length': data.length.toString() }\n      : {}\n\n    await this.fetch(this.src.dataUrl, {\n      method: 'PUT',\n      headers: headers,\n      data,\n    })\n  }\n\n  /**\n   * Fetch the Secrets as indicated by this event context\n   *\n   * @param key - The name of the secret to fetch\n   * @param options - (Optional) environmentId and spaceId to override event context\n   *\n   * @returns The value of the secret (usually a credential or token)\n   */\n  async secrets(\n    key: string,\n    options?: { environmentId?: string; spaceId?: string }\n  ) {\n    // Allow options overrides, then take from context, else are absent\n    const environmentId =\n      options?.environmentId || this.context.environmentId || ''\n    const spaceId = options?.spaceId || this.context.spaceId || ''\n\n    if (!environmentId) {\n      throw new Error('environmentId is required to fetch secrets')\n    }\n\n    let getSecrets = `v1/secrets?environmentId=${environmentId}`\n\n    if (spaceId) {\n      getSecrets += `&spaceId=${spaceId}`\n    }\n\n    const secretCacheKey = `secrets:${environmentId}${spaceId && `:${spaceId}`}`\n\n    const secrets = await this.cache.init(secretCacheKey, async () => {\n      const secretsResponse = await this.fetch(getSecrets)\n      const SecretMap = new Map<string, string>()\n      secretsResponse?.forEach((secret: { name: string; value: string }) => {\n        SecretMap.set(secret.name, secret.value)\n      })\n      return SecretMap\n    })\n\n    const value = secrets.get(key)\n    if (!value) {\n      throw new Error(`Secret ${key} not found`)\n    }\n    return value\n  }\n}\n\nexport type EventCallback = (evt: FlatfileEvent) => void | Promise<void>\n","import { Arrayable } from './event.handler'\nimport wildMatch from 'wildcard-match'\nimport flat from 'flat'\n\n/**\n * Glob style matching of a value\n *\n * @param val\n * @param filter\n */\nexport function glob(val: any, filter: string | string[]): boolean {\n  if (!val || typeof val !== 'string') {\n    return false\n  }\n  return wildMatch(filter || '**', ':')(val)\n}\n\n/**\n * Glob style matching of values in an object\n *\n * @param object\n * @param filterObject\n */\nexport function objectMatches(\n  object: Record<string, any>,\n  filterObject: JSONPrimitive | FilterObj\n): boolean {\n  const cleanFilter: FilterObj =\n    !filterObject || typeof filterObject !== 'object'\n      ? { '**': filterObject }\n      : filterObject\n\n  if (typeof object !== 'object') {\n    throw new Error('You cannot filter a non-object')\n  }\n  let denied = false\n  const filter: FilterObj = flat(cleanFilter, { safe: true })\n  const flattened = flat(object, { safe: true }) as Record<\n    string,\n    JSONPrimitive\n  >\n\n  // all filters MUST resolve true\n  for (const keyPattern in filter) {\n    const keys = filterKeys(flattened, keyPattern)\n\n    const valuePattern = (\n      Array.isArray(filter[keyPattern])\n        ? filter[keyPattern]\n        : [filter[keyPattern]]\n    ) as JSONPrimitive[]\n\n    // only one filter must match\n    denied ||= !keys.some((key) => {\n      const value: JSONPrimitive = flattened[key]\n      return valuePattern.some((match) => globOrMatch(value, match))\n    })\n  }\n  return !denied\n}\n\n/**\n * Glob keys of an object and return the narrowed set\n *\n * @param object\n * @param glob\n */\nfunction filterKeys<T extends Record<string, any>>(\n  object: Record<string, any>,\n  glob: string\n): Array<keyof T> {\n  glob = glob.includes('*') || glob.includes('.') ? glob : `**.${glob}`\n  const matcher = wildMatch(glob, '.')\n  return Object.keys(object).filter((key) => matcher(key))\n}\n\nfunction globOrMatch(\n  val: Arrayable<JSONPrimitive>,\n  filter: JSONPrimitive\n): boolean {\n  if (val === undefined || val === null) {\n    return filter === null\n  }\n  if (Array.isArray(val)) {\n    return val.some((v) => globOrMatch(v, filter))\n  }\n  if (typeof filter === 'string') {\n    return glob(val.toString(), filter)\n  }\n\n  // otherwise do a simple comparison\n  return val === filter\n}\n\ntype JSONPrimitive = string | number | boolean | null\n\ntype FilterObj = Record<\n  string,\n  Arrayable<JSONPrimitive> | Record<string, Arrayable<JSONPrimitive>>\n>\n","import { AuthenticatedClient } from './authenticated.client'\nimport { EventCallback, FlatfileEvent } from './flatfile.event'\nimport { glob, objectMatches } from './glob.match'\nimport type { Flatfile } from '@flatfile/api'\n\n/**\n * EventHandler is a Flatfile flavored implementation of EventTarget\n */\nexport class EventHandler extends AuthenticatedClient {\n  /**\n   * Apply a filter to the values of an event\n   */\n  public readonly filterQuery?: EventFilter\n\n  /**\n   * Cache of registered listeners on this instance\n   * @private\n   */\n  protected listeners: [string | string[], EventFilter, EventCallback][] = []\n\n  constructor(filter?: EventFilter, accessToken?: string, apiUrl?: string) {\n    super(accessToken, apiUrl)\n    if (filter) {\n      this.filterQuery = filter\n    }\n  }\n\n  /**\n   * Cache of registered child nodes for this listener. These nodes will\n   * only receive events that pass the parent filter.\n   *\n   * @private\n   */\n  protected nodes: EventHandler[] = []\n\n  /**\n   * Register a subscriber for events that match this path\n   */\n  on(query: Arrayable<string>, callback: EventCallback): this\n  on(\n    query: Arrayable<string>,\n    filter: EventFilter,\n    callback: EventCallback\n  ): this\n  on(\n    query: Arrayable<string>,\n    ...rest: [EventCallback] | [EventFilter, EventCallback]\n  ): this {\n    let filter: EventFilter = {}\n    const callback: EventCallback = rest.pop() as EventCallback\n\n    if (rest.length) {\n      filter = rest.shift() as EventFilter\n    }\n\n    this.listeners.push([query, filter, callback])\n\n    return this\n  }\n\n  /**\n   * Add child nodes to send this event to as well\n   *\n   * @param node\n   */\n  addNode(node: EventHandler): this {\n    this.nodes.push(node)\n    return this\n  }\n\n  /**\n   * Dispatch an event and resolve the promise once it has completed (or\n   * errored\n   *\n   * @todo - is there a right order in which to resolve event listeners?\n   *   Should it matter?\n   *\n   * @param event\n   */\n  async dispatchEvent(\n    event: FlatfileEvent | Flatfile.Event | any\n  ): Promise<void> {\n    if (!event) return\n    const eventPayload = event.src ? event.src : event\n\n    event = new FlatfileEvent(eventPayload, this._accessToken, this._apiUrl)\n\n    await this.trigger(event, true)\n\n    for (const [_key, cb] of event.afterAllCallbacks) {\n      await cb(event)\n    }\n\n    event.cache.delete()\n  }\n\n  /**\n   * @deprecated legacy shim for receiving events from the VM layer\n   * @alias dispatchEvent\n   * @param event\n   */\n  async routeEvent(event: Flatfile.Event) {\n    return this.dispatchEvent(event)\n  }\n\n  /**\n   * Actually trigger the event listeners on this particular target\n   *\n   * @note It is safer for now to run this in series to avoid IO locks and\n   *       potential race conditions and uncaught errors\n   *\n   * @param event\n   * @param recursive\n   */\n  async trigger(\n    event: FlatfileEvent,\n    recursive: boolean = false\n  ): Promise<void> {\n    const listeners = this.getListeners(event, recursive)\n    for (const cb of listeners) {\n      await cb.callback(event)\n    }\n  }\n\n  /**\n   * Get any listeners from this target subscribing to this event\n   *\n   * @param event\n   * @param recursive\n   */\n  public getListeners(\n    event: FlatfileEvent,\n    recursive: boolean = false\n  ): Listener[] {\n    // never return any listeners if the event doesn't match the filter\n    // event recursion should not occur either\n    if (!this.matchEvent(event, this.filterQuery)) {\n      return []\n    }\n\n    // look at listeners registered here\n    const listeners = this.listeners\n      .filter(([query, filter]) => {\n        const globbed = glob(event.topic, query)\n        const matched = this.matchEvent(event, filter)\n        return globbed && matched\n      })\n      .map(([query, filter, callback]) => ({ query, filter, callback }))\n\n    return !recursive\n      ? listeners\n      : [\n          ...listeners,\n          ...this.nodes.flatMap((n) => n.getListeners(event, true)),\n        ]\n  }\n\n  /**\n   * Attach more event listeners using a callback function. Used most\n   * frequently for plugins.\n   *\n   * @param fn\n   */\n  use(fn: (handler: this) => void): this {\n    fn(this)\n    return this\n  }\n\n  /**\n   * Filter an event out based on glob filter object\n   *\n   * @param event\n   * @param filter\n   */\n  public matchEvent(\n    event: FlatfileEvent,\n    filter: EventFilter | undefined\n  ): boolean {\n    return filter ? objectMatches(event, filter) : true\n  }\n}\n\nexport type EventFilter = Record<\n  string,\n  any\n  // TODO: Open question - 1 level nested object. Do we want/need more than that?\n  // Arrayable<string> | Record<string, Arrayable<string>>\n>\n\nexport type Arrayable<T> = T | Array<T>\nexport type Listener = {\n  query: string | string[]\n  filter: any\n  callback: EventCallback\n}\n","/**\n * The Flatfile Listener\n *\n * The Flatfile PubSub Client is just a simple event subscriber. It can\n * receive events from any PubSub driver. The default drivers are:\n *\n * - Webhook    (for simply processing events sent to URL)\n * - Websocket  (for subscribing real time on an HTTP2 connection)\n * - Serverless (for stateless invocations via AWS Lambda or similar)\n *\n * Once an event is received, it is routed to any awaiting listeners which\n * are added with `addEventListener()` or its alias `on()`.\n *\n * Flatfile events follow a standard structure and event listeners can use\n * any of the following syntaxes to react to events within Flatfile.\n *\n * // listen to an event\n * addEventListener('entity:topic')\n *\n * // listen to an event on a specific namespace\n * addEventListener('entity:topic@namespace')\n *\n * // listen to a specific context on a namespace\n * addEventListener('entity:topic@namespace?context=us_sp_89234oihsdo')\n *\n * // filter by any\n * addEventListener('entity:topic@namespace?')\n *\n */\n\nimport { EventFilter, EventHandler } from './events'\nimport { EventDriver } from './event-drivers'\n\nexport class FlatfileListener extends EventHandler {\n  /**\n   * Subscribe to events only within a certain namespace.\n   *\n   * @param namespace\n   * @param cb\n   */\n  namespace(namespaces: string | string[], cb?: SubFn<this>) {\n    return this.filter({ namespaces }, cb)\n  }\n\n  /**\n   * Filter by namespace\n   *\n   * @param filter\n   * @param cb\n   */\n  filter(filter: EventFilter, cb?: SubFn<this>): this {\n    const client = new (this.constructor as any)(filter)\n    this.addNode(client)\n    cb?.(client)\n    return client\n  }\n\n  /**\n   * Start subscribing to events\n   *\n   * @param cb\n   */\n  public static create<T extends FlatfileListener>(\n    this: Constructor<T>,\n    cb: SubFn<T>\n  ): T {\n    const client = new this()\n    cb(client)\n    return client\n  }\n\n  /**\n   * Mount this client using an acceptable Event Driver\n   */\n  mount(driver: EventDriver) {\n    driver.mountEventHandler(this)\n    return this\n  }\n}\n\ntype SubFn<T extends FlatfileListener> = (client: T) => void\n\ntype Constructor<T> = { new (): T }\n","import { EventHandler } from '../events'\n\nexport abstract class EventDriver {\n  _handler?: EventHandler\n\n  public get handler(): EventHandler {\n    if (!this._handler) {\n      throw new Error('handler not registered yet')\n    }\n    return this._handler\n  }\n\n  /**\n   * Mount an event handler\n   *\n   * @param handler\n   */\n  mountEventHandler(handler: EventHandler): this {\n    this._handler = handler\n    return this\n  }\n\n  /**\n   * Dispatch an event\n   *\n   * @param e\n   */\n  dispatchEvent(e: any): this {\n    this.handler.dispatchEvent(e)\n    return this\n  }\n}\n","import { EventDriver } from './_EventDriver'\nimport { EventHandler } from '../events'\n\nexport class Browser extends EventDriver {\n  public _accessToken?: string\n  public _apiUrl?: string\n  public _environmentId?: string\n\n  constructor({\n    apiUrl,\n    accessToken,\n    environmentId,\n  }: {\n    apiUrl: string\n    accessToken: string\n    environmentId?: string\n    /**\n     * @deprecated\n     */\n    fetchApi: any\n  }) {\n    super()\n    this._apiUrl = apiUrl\n    this._accessToken = accessToken\n    this._environmentId = environmentId || ''\n  }\n\n  mountEventHandler(handler: EventHandler): this {\n    handler.setVariables({\n      accessToken: this._accessToken,\n      apiUrl: this._apiUrl,\n    })\n\n    this._handler = handler\n    return this\n  }\n}\n","import { EventDriver } from './_EventDriver'\nimport { EventHandler, FlatfileEvent } from '../events'\n\n/**\n * Flatfile's Virtual Machine is stateless / serverless. So when a new event\n * is handled, it will just call `handle(event)`.\n */\nexport class FlatfileVirtualMachine extends EventDriver {\n  /**\n   * This method is triggered from within the Flatfile Core VM Runner. This\n   * EventDriver does not have to listen for events because this method will\n   * be invoked as necessary.\n   *\n   * @param event\n   */\n\n  handle(event: FlatfileEvent) {\n    this.dispatchEvent(event)\n  }\n\n  mountEventHandler(handler: EventHandler): this {\n    this._handler = handler\n    return this\n  }\n}\n","import { FlatfileListener } from './flatfile.listener'\nexport * from './flatfile.listener'\nexport * from './event-drivers'\nexport * from './events'\n\n/**\n * Backwards compatibility\n */\nexport class Client extends FlatfileListener {}\n\nexport default FlatfileListener\n"],"names":["CrossEnvConfig","get","prop","this","safeEnvLookup","set","key","value","_overrides","alias","from","to","_aliases","attachConfigRegistry","obj","_registry","attachConfigFactory","cb","_factory","reset","Map","values","push","process","env","checkForBrowserVariables","foundValue","find","v","window","windowValue","sessionStorage","storedValue","getItem","AuthenticatedClient","constructor","accessToken","apiUrl","FLATFILE_API_URL","bearerToken","_accessToken","_apiUrl","url","endsWith","slice","ensureSingleTrailingSlash","undefined","fetch","options","headers","Authorization","fetchUrl","fetchOptions","method","body","data","response","status","contentType","includes","json","text","Error","err","console","log","setVariables","EventCache","eventCache","init","callback","result","Array","isArray","forEach","k","delete","clear","FlatfileEvent","src","super","afterAllCallbacks","cache","domain","topic","context","payload","target","origin","action","actionName","namespace","namespaces","createdAt","async","fetchData","then","onfulfilled","onrejected","dataUrl","URLSearchParams","Object","entries","append","decodedURL","decodeURIComponent","toString","afterAll","cacheKey","update","records","compressRequestBody","map","record","messages","message","source","pako","gzip","JSON","stringify","length","secrets","environmentId","spaceId","getSecrets","secretCacheKey","secretsResponse","SecretMap","secret","name","glob","val","filter","wildMatch","filterKeys","object","matcher","keys","globOrMatch","some","EventHandler","listeners","nodes","filterQuery","on","query","rest","pop","shift","addNode","node","dispatchEvent","event","eventPayload","trigger","_key","routeEvent","recursive","getListeners","matchEvent","globbed","matched","flatMap","n","use","fn","filterObject","cleanFilter","denied","flat","safe","flattened","keyPattern","valuePattern","match","objectMatches","FlatfileListener","client","create","mount","driver","mountEventHandler","EventDriver","handler","_handler","e","Browser","_environmentId","FlatfileVirtualMachine","handle","Client"],"mappings":"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"}