import { Flatfile } from '@flatfile/api';
import { FlatfileEvent } from '@flatfile/listener';

declare function getRecordsRaw(sheetId: string, options?: Flatfile.records.GetRecordsRequest): Promise<Array<Flatfile.Record_>>;
declare function getSheetLength(sheetId: string): Promise<number>;
declare function processRecords<R>(sheetId: string, callback: (records: Flatfile.RecordsWithLinks, pageNumber?: number, totalPageCount?: number) => R | void | Promise<R | void>, options?: Omit<Flatfile.records.GetRecordsRequest, 'pageNumber'>): Promise<R[] | void>;
/**
 * Creates records in a sheet. Bypasses API SDK in order to suppress hooks
 */
declare function createRecords(sheetId: string, records: Flatfile.RecordData[]): Promise<string>;
/**
 * Updates records in a sheet. Bypasses API SDK in order to suppress hooks
 */
declare function updateRecords(sheetId: string, records: any): Promise<string>;
/**
 * Updates records in a sheet. Bypasses API SDK in order to suppress hooks
 */
declare function updateAllRecords(sheetId: string, records: Flatfile.Record_[], tick?: TickHelper): Promise<void>;
/**
 * Creates many records in a sheet. Bypasses API SDK in order to suppress hooks
 */
declare function createAllRecords(sheetId: string, records: Flatfile.RecordData[], tick?: TickHelper): Promise<void>;
type TickHelper = (progress: number, part: number, totalParts: number) => Promise<void>;

declare function asyncBatch<T, R>(arr: T[], callback: (chunk: T[], event?: FlatfileEvent) => Promise<R>, options?: {
    chunkSize?: number;
    parallel?: number;
    debug?: boolean;
}, event?: FlatfileEvent): Promise<R[]>;
declare function chunkify<T>(arr: T[], chunkSize: number): T[][];

declare function deleteRecords(sheetId: string, config: Omit<Flatfile.DeleteRecordsJobConfig, 'sheet'>): Promise<void>;

type LogType = 'log' | 'warn' | 'error';
declare const log: (packageName: string, msg: string, type?: LogType) => void;
declare const logInfo: (packageName: string, msg: string) => void;
declare const logWarn: (packageName: string, msg: string) => void;
declare const logError: (packageName: string, msg: string) => void;

declare const slugify: (str: string) => string;

declare class Simplified {
    /**
     * Return all records for a sheet
     *
     * @param sheetId
     * @param options
     * @param tick
     */
    static getAllRecords(sheetId: string, options?: Flatfile.records.GetRecordsRequest, tick?: TickHelper): Promise<SimpleRecord[]>;
    /**
     * Return all records for a sheet by iterating until there are empty pages.
     * This is most useful in scenarios where pages are generally small but you want
     * to safely handle edge cases. It avoids another count request.
     *
     * @param sheetId
     * @param options
     */
    static getAllRecordsSeries(sheetId: string, options?: Flatfile.records.GetRecordsRequest): Promise<SimpleRecord[]>;
    static findRecordsLimit(sheetId: string, options: Flatfile.records.GetRecordsRequest, limit?: number): Promise<SimpleRecord[]>;
    /**
     * { foo: bar } => { foo : {value: bar}}
     * @param obj
     */
    static toRecordValues(obj: SimpleRecord): Flatfile.RecordData;
    static toStandardRecord(obj: SimpleRecord): {
        id: string;
        metadata: any;
        values: Flatfile.RecordData;
    };
    /**
     *
     * @param r
     */
    static toSimpleRecord(r: Flatfile.Record_): SimpleRecord;
    static updateAllRecords(sheetId: string, records: SimpleRecord[], tick?: TickHelper): Promise<void>;
    static createAllRecords(sheetId: string, records: SimpleValues[], tick?: TickHelper): Promise<void>;
}
type Primitive = string | number | null | boolean;
type SimpleRecord = {
    _id: string;
    _metadata?: Record<string, any>;
} & SimpleValues;
type SimpleValues = {
    [key: string]: Primitive;
};

export { type Primitive, type SimpleRecord, type SimpleValues, Simplified, type TickHelper, asyncBatch, chunkify, createAllRecords, createRecords, deleteRecords, getRecordsRaw, getSheetLength, log, logError, logInfo, logWarn, processRecords, slugify, updateAllRecords, updateRecords };
